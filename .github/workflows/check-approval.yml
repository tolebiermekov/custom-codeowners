name: Check PR Approval

on:
  pull_request_review:
    types: [submitted]

permissions:
  pull-requests: read
  contents: read

jobs:
  check-approvals:
    if: github.event.pull_request.base.ref == 'main'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'

      - name: Check Approvals
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python - <<EOF
          import os
          import sys
          import json
          import urllib.request
          import urllib.error
          import logging
          from pathlib import Path
          import shlex
          
          logging.basicConfig(level=logging.INFO, format='%(message)s', stream=sys.stdout)
          
          TOKEN = os.environ.get('GITHUB_TOKEN', '')
          HEADERS = {
              'Authorization': f'token {TOKEN}',
              'Accept': 'application/vnd.github.v3+json'
          }
          CODEOWNERS_FILE = '.github/CODEOWNERS-DWH'

          def fail(message):
              logging.error(f"::error::{message}")
              sys.exit(1)

          def make_request(url):
              req = urllib.request.Request(url, headers=HEADERS)
              try:
                  with urllib.request.urlopen(req) as response:
                      if response.status >= 300:
                          raise Exception(f"API request failed with status {response.status}: {response.read().decode()}")
                      return json.loads(response.read().decode('utf-8'))
              except urllib.error.HTTPError as e:
                  raise Exception(f"HTTPError when requesting {url}: {e.code} {e.reason}")
              except Exception as e:
                  raise Exception(f"Failed during request to {url}: {e}")

          def get_pr_context():
              try:
                  repo_full = os.environ['GITHUB_REPOSITORY']
                  owner, repo = repo_full.split('/')
                  with open(os.environ['GITHUB_EVENT_PATH'], 'r') as f:
                      event_data = json.load(f)
                  pr_number = event_data['pull_request']['number']
                  return owner, repo, pr_number
              except Exception as e:
                  fail(f"Failed to get PR context: {e}")

          def parse_codeowners(filepath):
              """
              Parses the CODEOWNERS file.
              This is the core logic for translating .gitignore-style
              patterns into patterns that `pathlib` can understand.
              """
              rules = []
              try:
                  with open(filepath, 'r') as f:
                      for line_number, line in enumerate(f, 1):
                          # Strip comments and whitespace *before* parsing.
                          line = line.split('#', 1)[0].strip()
                          if not line:
                              continue
                          
                          try:
                              # Correctly handles paths in quotes or with backslash-escaped spaces
                              parts = shlex.split(line)
                          except ValueError as e:
                              logging.warning(f"Skipping malformed line {line_number}: {line} | Error: {e}")
                              continue
                          if not parts:
                              continue
                              
                          raw_pattern = parts[0]
                          owner_strings = parts[1:]
                          
                          if raw_pattern == '*':
                              pattern = '*'  # Handle the global '*' glob
                          elif raw_pattern == '**':
                              pattern = '**' # Handle the global recursive '**' glob
                          elif raw_pattern.startswith('/'):
                              # Handle root-anchored paths.
                              # pathlib.match() is root-anchored by default, so just strip the '/'.
                              pattern = raw_pattern[1:]
                          else:
                              # Handle "floating" paths. Prepend '**/' to match anywhere.
                              pattern = f"**/{raw_pattern}"
          
                          # EDGE CASE: Fix for pathlib's handling of '**'.
                          # A pattern like '.../docs/**' needs to become '.../docs/**/*'
                          # to correctly match files *within* that directory.
                          if pattern.endswith('/**') and pattern != '**':
                              pattern = f"{pattern}/*"

                          # Explicitly filter out team owners (`@org/team`) by checking for '/'. 
                          # This action only supports individual user owners.
                          owners = {o.replace('@', '') for o in owner_strings if '/' not in o}
                          if not owners:
                              logging.warning(f"No owners found for pattern on line {line_number}: {raw_pattern}")
                              continue
                              
                          rules.append({'pattern': pattern, 'owners': owners})
              
              except FileNotFoundError:
                  fail(f"Failed to read {filepath}: File not found.")
              except Exception as e:
                  fail(f"Failed to parse {filepath}: {e}")
              
              return rules

          def get_changed_files(owner, repo, pr_number):
              files_url = f'https://api.github.com/repos/{owner}/{repo}/pulls/{pr_number}/files'
              files_json = make_request(files_url)
              return [Path(f['filename']) for f in files_json]

          def get_approved_users(owner, repo, pr_number):
              reviews_url = f'https://api.github.com/repos/{owner}/{repo}/pulls/{pr_number}/reviews'
              reviews_json = make_request(reviews_url)
              approved_users = {
                  review['user']['login']
                  for review in reviews_json
                  if review['state'] == 'APPROVED'
              }
              return approved_users

          def check_file_coverage(changed_files, rules, approved_users):
              """Checks every changed file against the ruleset."""
              uncovered_files_list = []
              
              reversed_rules = list(reversed(rules))

              for file_path in changed_files:
                  found_owners = None
                  for rule in reversed_rules:
                      if file_path.match(rule['pattern']):
                          found_owners = rule['owners']
                          break
                  
                  if not found_owners:
                      logging.warning(f"File {file_path} has no owner in CODEOWNERS-DWH. Failing.")
                      uncovered_files_list.append(f"- {file_path} (has NO owner assigned in CODEOWNERS-DWH)")
                      continue
                  
                  intersection = approved_users.intersection(found_owners)
                  if not intersection:
                      uncovered_files_list.append(f"- {file_path} (requires: {', '.join(found_owners)})")
                  else:
                      logging.info(f"PR for {file_path} is covered by approval from: {', '.join(intersection)}")
              
              return uncovered_files_list

          def main():
              try:
                  if not TOKEN:
                      fail("GITHUB_TOKEN is not set.")
          
                  owner, repo, pr_number = get_pr_context()
                  rules = parse_codeowners(CODEOWNERS_FILE)
                  changed_files = get_changed_files(owner, repo, pr_number)
                  approved_users = get_approved_users(owner, repo, pr_number)
          
                  if not approved_users:
                      fail('No "Approve" found on this PR.')
                  logging.info(f"Found approvals from: {', '.join(approved_users)}")
          
                  uncovered_files = check_file_coverage(changed_files, rules, approved_users)
          
                  if uncovered_files:
                      uncovered_files_str = '\n'.join(uncovered_files)
                      error_message = (
                          f"Not all files are covered by approval. "
                          f"Approver(s) {', '.join(approved_users)} do not have permissions for:\n"
                          f"{uncovered_files_str}"
                      )
                      fail(error_message)
                  else:
                      logging.info("All changed files are covered by owners.")
              
              except Exception as e:
                  fail(f"An unexpected error occurred: {e}")

          if __name__ == "__main__":
              main()
          EOF